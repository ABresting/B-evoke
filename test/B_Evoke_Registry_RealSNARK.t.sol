// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/Groth16Verifier.sol";

/**
 * @title B_Evoke_Registry_RealSNARK Test
 * @dev Test the REAL Groth16Verifier with actual SNARK proofs
 */
contract B_Evoke_Registry_RealSNARKTest is Test {
    Groth16Verifier public verifier;

    function setUp() public {
        // Deploy the real Groth16Verifier
        verifier = new Groth16Verifier();
    }

    function testVerifyRealProof() public {
        // This proof was generated by proof-service.js
        // Old Accumulator: 12345678901234567890
        // New Element: 98765432109876543210
        // Secret: (random)
        // New Accumulator: 19722334623012146112934323806811353212967923478622013599640272973627197930356

        // Proof components (from proof.json)
        uint[2] memory pA = [
            uint256(2881647231689393391682792646245554288311235178178801255335568818377925735143),
            uint256(18005980232008168462848271416164453251879899690278288236579251937368168825123)
        ];

        uint[2][2] memory pB = [
            [
                uint256(17921833006673001729169852784517153403175080952189438616290647111530085163927),
                uint256(15106839188485666673936221694249658080479494174130817019356968923139484155432)
            ],
            [
                uint256(15697488969667817623087346221583891186640788698293045309003096955066169857164),
                uint256(21812215330471359357923491001940102688149872551714696160617090107677372833345)
            ]
        ];

        uint[2] memory pC = [
            uint256(7277179585922472471122223661591673277992057881782434119988055832707110682063),
            uint256(19725481430027813199586430229425420815122501313581806929564747851399488977947)
        ];

        // Public signal: new accumulator value
        uint[1] memory pubSignals = [
            uint256(19722334623012146112934323806811353212967923478622013599640272973627197930356)
        ];

        // Verify the proof!
        bool isValid = verifier.verifyProof(pA, pB, pC, pubSignals);

        // The proof should be VALID!
        assertTrue(isValid, "Real SNARK proof should be valid!");
    }

    function testInvalidProofFails() public {
        // Test with invalid proof (all zeros)
        uint[2] memory pA = [uint256(1), uint256(2)];
        uint[2][2] memory pB = [[uint256(3), uint256(4)], [uint256(5), uint256(6)]];
        uint[2] memory pC = [uint256(7), uint256(8)];
        uint[1] memory pubSignals = [uint256(999)];

        bool isValid = verifier.verifyProof(pA, pB, pC, pubSignals);

        // Invalid proof should fail
        assertFalse(isValid, "Invalid proof should not verify");
    }

    function testRealProofWithWrongPublicSignal() public {
        // Valid proof components
        uint[2] memory pA = [
            uint256(2881647231689393391682792646245554288311235178178801255335568818377925735143),
            uint256(18005980232008168462848271416164453251879899690278288236579251937368168825123)
        ];

        uint[2][2] memory pB = [
            [
                uint256(17921833006673001729169852784517153403175080952189438616290647111530085163927),
                uint256(15106839188485666673936221694249658080479494174130817019356968923139484155432)
            ],
            [
                uint256(15697488969667817623087346221583891186640788698293045309003096955066169857164),
                uint256(21812215330471359357923491001940102688149872551714696160617090107677372833345)
            ]
        ];

        uint[2] memory pC = [
            uint256(7277179585922472471122223661591673277992057881782434119988055832707110682063),
            uint256(19725481430027813199586430229425420815122501313581806929564747851399488977947)
        ];

        // WRONG public signal (should make proof invalid)
        uint[1] memory pubSignals = [uint256(12345)];

        bool isValid = verifier.verifyProof(pA, pB, pC, pubSignals);

        // Should fail with wrong public signal
        assertFalse(isValid, "Proof with wrong public signal should fail");
    }
}